# The specification generator

The specification generator is a collection of tools to generate different artifacts based on the output of the OSLO tool EA-to-RDF.

The tools are
 - json-ld-generator.js: a tool to generate a complete json-ld context file for the output
 - exampletemplate-generator.js: this tool generates a json-ld context and default payload structure for each class in the specification.
 - html-generator.js: this tool generates html to be rendered by a static webpage server. The main target is Data.vlaanderen.be. The default templates to be used are found in the directory /views
 - shacl-generator.js: this tool generates SHACL templates
 
In addition some closely related tools are:
 - csv-renderer.js: this tool renders the content of a csv file according to a template generated by the exampletemplate-generator.
 - pretty-print.js: a tool to sort and pretty print the content of EA-to-RDF to create more stability in the saved artifacts created by the generators.

## build

This is a node.js project for node >= version 10.

```
npm set unsafe-perm true
npm install
```

The easiest method is the build it as a docker container using as Dockerfile  `Dockerfile.circleci`.

## Running the tools
To run any of the tools is done on the commandline as:
```
> node <tool>.js --help
```
which will give a short help about the tool.


## code style
In the node configuration the javascript code style is implemented in the test script using eslint.



## Strucutre of this repository

## Specification generator JS version
To minimize the impact of a different implementation language for the specification generator we will leave the templating engine untouched from an external perspective. The python implementation used Jinja2. We will use nunchucks.js for this version.

### necessary changes to the templates compared to the python implementation of nunjuncks.

The encountered differences between the python and javascript implementation are:
#### absence of a variable that is undergoing filtering
When a filter (selectattr, lower, ...) is used on a non existent variable then the template will crash. The solution here is to test the presence of the variable prior to filtering:
```
{% if object.property %}
  {{ object.property | lower }}
{% endif %}
```
#### lower() empty parameter method call not supported
In jinja the following construct is valid
```
# NOT SUPPORTED IN NUNJUCKS
{{ "TEST".lower()}}
```
for nunchucks this needs to be written as a 'true' filter such as
```
{{ "TEST" | lower }}
```

#### the complex form of the selectattr filter is not supported
The Jinja2 selectattr filter is not supported in the complex case. The simple case is supported though;
In jinja2 the following would filter out all object for which the property is set to 1
```
# NOT SUPPORTED IN NUNJUCKS
{{ objects | selectattr('property', 'equalto', 1)}}
```

The simple case of this filter is similar but wil only test for truthy values ( property in object && object.property != false ). This would look like:
```
{{ objects | selectattr('property')}}
```
To handle the complex case in nunjucks the following construct, base on groupings will work:
```
{% for property, objects in objects | groupby(property) %}
  {% if property == 1 %}
    # handle the filtered objects here
  {% endif %}
{% endfor %}
```

#### Autoescaping is enabled
For all templates, the given variables (the values of the jsonld) will be autoescaped. This means any characters that might be interpreted (e.g. '<', '>', ...) will be replaced with a neutral string and displayed as such. Autoescaping is currently deactivated for the usage values and can be for any variable if the safe filter is added. Doing so requires all entered values to be html safe and might cause errors if they are not.
```
{{ entity.usage[language] | safe }}
```

#### Usage of the mu-config-generator.js  
The mu-config-generator.js automatically creates you a mu-semtech-project configuration based on the jsonld of your specification. For that, you have to enter said jsonld, a language that is needed to access the name value and an output directory. That directory you should either set to the config->resources directory in your mu-semtech-project or copied the created files into that.  
Some decisions had been made beforehand. One of which is that, when a class is in the domain-parameter of a property, it will have said property relationship as a "has-one"-value while, if the object is in the range-parameter, it will have an inverse "has-many" connection. Each class has three attributes: name, definition and usage. By default, these are not language tagged. If you want them to be, you have to go to l. 164 - l. 166 and change ":string" to ":language-string" (or only some of those lines). Another recommendation is to check over the defined paths as they are creating automatically created plurals of the class names and do not consider any irregular plurals or even some of the usual cases and cause grammatic errors. You can see an illustration of that in the example code below where "Address" was written as "Addresss".  
In the following there is an example on how to create an address object based on this config:  
```
(define-resource Address ()
   :class (s-url "http://www.w3.org/2002/07/owl#Class")
   :properties `((:definition :string ,(s-prefix "sh:definition"))
                 (:name :string ,(s-prefix "sh:name"))
                 (:usage :string ,(s-prefix "sh:usage")))
   :has-one `((Location :via ,(s-url "https://sdg.semic.euAddress.address")
                        :as "Location"))
:resource-base (s-url "https://sdg.semic.euAddress")
:on-path "Addresss")
```
For this, you can send a post request with the following body to the path of your project and the ending /Addresss. As a header you need to define "Content-Type" as "application/vnd.api+json".  
```
{
  "data": {
    "type": "Addresss",
    "attributes": {
      "name": "An Address",
      "definition": "A Description",
      "usage": "A Usage"
    },
    "relationships": {
      "Location": {
        "data": {
          "type": "Locations",
          "id": "5FCFCE2A873EE90008000001"
        }
      }
    }
  }
}
```
Assuming the ID points to a location object that already exist, this will create an address that has a tripel like this:  
`<AddressURI> <https://sdg.semic.euAddress.address> <LocationURI>.`  
If you change the :string to a :language-string, the following will work:  
```
{
  "data": {
    "type": "Addresss",
    "attributes": {
      "name": {
        "language": "en",
        "content": "An Address"
      },
      "definition": {
        "language": "en",
        "content": "A Description"
      },
      "usage": {
        "language": "en",
        "content": "A Usage"
      },
    "relationships": {
      "Location": {
        "data": {
          "type": "Locations",
          "id": "5FCFCE2A873EE90008000001"
        }
      }
    }
  }
}
```
In this case, one of the created triples would be:  
`<AddressURI> sh:name "An Addres"@en .`